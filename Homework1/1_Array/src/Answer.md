1. 关于 `copyOfRange` 的第3个参数

`copyOfRange` 的第3个参数表示复制操作中不包含的源数组结束位置索引。例如，`Arrays.copyOfRange(arr, 1, 4)` 会复制索引为1、2、3的元素，但不包括索引4的元素。这类似于Java中字符串的 `substring` 方法，表示的是一个左闭右开的区间[start, end)。

2. 关于二维数组排序

使用 `Arrays.sort()` 方法可以直接对二维数组进行排序，但是它默认只会按照每个一维数组的引用地址排序，而不是按照一维数组中的内容排序。如果需要按照数组内容排序，需要提供自定义的比较器(Comparator)。

对于题目要求，可以将二维数组复制到一维数组，排序后再复制回去。也可以使用 `Arrays.sort()` 配合Comparator来实现，但通常直接操作一维数组更简单直接。

3. `copyOfRange` 和 `copyOf` 的主要区别是什么？

* `copyOf(T[] original, int newLength)` 只需要指定新数组的长度，会从原数组的开始位置复制元素。
* `copyOfRange(T[] original, int from, int to)` 可以指定从原数组的哪个位置开始复制，到哪个位置结束(不包含结束位置的元素)。
* 如果新数组长度大于原数组被复制部分的长度，多余的位置会用类型默认值填充（对于数值型是0，对象引用是null）。

4. 选择排序和冒泡排序的时间复杂度是多少？在什么情况下一种可能比另一种更有优势？

* 选择排序和冒泡排序的平均时间复杂度都是O(n²)。
* 选择排序的交换操作次数是O(n)，而冒泡排序在最坏情况下需要O(n²)次交换。
* 当数组已经接近有序时，冒泡排序可以通过标志位优化，在最好情况下达到O(n)的时间复杂度。
* 当交换操作代价较高时，选择排序可能更有优势，因为它进行的交换次数较少。

5. Arrays.fill方法的局限性是什么？在填充复杂对象数组时需要注意什么？

* Arrays.fill只能用相同的值填充数组的所有元素。
* 对于对象数组，fill方法会将相同的对象引用复制到数组的每个位置，而不是创建对象的副本。
* 这意味着如果填充的是可变对象，修改数组中任一元素会影响所有元素，因为它们引用的是同一个对象。
* 如果需要填充对象的独立副本，需要在填充后手动遍历数组并创建新对象。